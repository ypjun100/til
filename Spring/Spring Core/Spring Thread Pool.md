# Spring Thread Pool

### Thread Pool
* **여러 개의 대기 상태인 쓰레드를 미리 생성한 뒤, 작업 요청 시 쓰레드를 가져와 처리하는 구조**
* 작업이 완료되면 해당 작업을 하는데 사용된 쓰레드는 쓰레드 풀로 다시 반환되어 다음 작업을 기다림
* 이러한 구조를 통해 **쓰레드를 생성하고 종료하는 데 사용되는 비용을 절감**할 수 있음

> 새로운 쓰레드가 생성되기 위해서는 자원을 할당받고, 쓰레드를 초기화하는 등의 커널 단과의 통신이 많이 필요하며, 이 과정에서 많은 비용 및 시간이 요구된다. 쓰레드를 종료하는 작업 또한, 할당된 자원을 해제하는 등의 비용이 많이 든다.

### Spring Thread Pool
* 초기 Tomcat에서는 클라이언트 요청이 들어올 때 새로운 쓰레드를 생성하는 방법을 채택함
* 이 방법은 쓰레드가 계속 확장할 수 있으나 그만큼의 비용이 소모되는 문제가 있음
* 따라서, **Tomcat에 Thread Pool 구조를 적용하여, 필요에 따라 쓰레드를 가져오고 반환하도록 함**

![](https://blog.kakaocdn.net/dn/qb5bg/btseQSOcEPQ/Py0HOj27zH64yQFCZCgiak/img.png)

* Thread Pool에서 전체 쓰레드가 사용 중인 경우, 쓰레드를 할당받지 못한 작업은 작업 큐에서 대기함
* 한 작업 당 하나의 쓰레드를 가지며, 작업이 완료되면 결과값을 반환한 뒤에 쓰레드를 반환함

```yml
// Spring에서 Thread Pool 설정 (기본값)
server:
	tomcat:
		accept-count: 100     # TCP 연결 대기 큐의 사이즈
		max-connections: 8192 # 동시에 연결될 수 있는 최대 TCP 커넥션 수
		threads:
			max: 200          # 생성할 수 있는 최대 쓰레드 수
			min-spare: 10     # Thread Pool에 대기 상태로 있는 쓰레드 수
```

> `accept-count`는 클라이언트가 `max-connections`의 수보다 더 많이 요청할 때 클라이언트가 대기하는 요청 대기열 큐의 크기를 설정한다. 만약 `max-connections` + `accept_count` 보다 **더 많은 클라이언트가 요청하는 경우 이후의 요청들은 연결을 거부한다.**

> 처음 쓰레드 풀은 `min-spare` 만큼의 쓰레드를 풀에 미리 생성해놓고 요청을 대기하게 된다. 그리고 클라이언트의 요청을 받으면 이 쓰레드들을 이용하여 요청을 처리하다가 요청의 수가 `min-spare`를 넘으면 필요한 만큼 풀에 쓰레드를 추가시킨다. 이때 쓰레드 풀에 생성될 수 있는 최대 쓰레드의 수는 `max`로 지정한다.

> Spring은 클라이언트의 요청을 처리하기 위한 내부적으로 두 개의 큐를 가지고 있으며, 하나는 위에서 설명한 TCP 연결 대기 큐이고, 나머지 하나는 TCP 연결에 수립된 요청들이 쓰레드를 할당받기 위해 대기하는 큐가 존재한다.