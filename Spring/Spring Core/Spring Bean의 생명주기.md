# Spring Bean의 생명주기

![스크린샷 2024-07-25 10 43 40](https://github.com/user-attachments/assets/3baa7751-30ae-4178-9f75-b48026687176)

## Bean Definitions Loaded
* 이 단계에서는 3가지의 소스를 통해 빈(Bean)에 대한 메타데이터를 BeanFactory에 저장하게 됨
	* 직접적으로 빈을 생성하는 것이 아닌, 빈을 생성하기 위한 레퍼런스 및 메타데이터를 생성함
* 빈을 정의하기 위한 `Java를 이용한 구성`, `XML을 이용한 구성`, `컴포넌트 스캔 및 자동 설정`방법이 있음
	* `Java를 이용한 구성`은 다른 방법들과 달리, 빈 정의를 위한 실제 객체를 생성하게 됨
	* `XML을 이용한 구성`은 과거에 사용되던 방법으로, 최근에는 거의 사용되지 않음
	* `컴포넌트 스캔 및 자동 설정`은 자동으로 특정 범위 내의 클래스들을 스캔하여 정의함
* 빈을 정의하기 위한 소스는 위 3가지 방법 중 하나여도 상관없고, 둘 이상이여도 상관없음

### Post-process Bean Definitions
* 이 단계에서는 실제로 빈이 생성되기 이전에 생성될 빈들에 대한 설정이나 변경 작업이 포함됨
	* 이 과정 중에 빈은 설정 내용들을 토대로 수정되거나 변환될 수 있음
	* 또한, 사용자가 직접 Custom Component를 생성할 수 있음
* 모든 작업은 BeanFactory를 기반하며, 작업이 완료되면 팩토리는 빈 주입에 필요한 레퍼런스를 가지게 됨
* 이 단계 이후에 BeanFactory와 빈들은 생성되기 위한 모든 설정을 마친 상태를 갖게 됨

### Instantiate Bean
* 각 빈에 대해 팩토리 내부에서 생성자를 이용하여 인스턴스화 되며, 생성 순서도 별로도 정의하게 됨
	* 종속성을 많이 가지고 있는 빈의 경우, 모든 종속성들을 생성한 뒤에 빈이 생성됨
* 빈은 `Lazy 빈`과 `Eager 빈`으로 구분할 수 있으며, 기본적으로 모든 빈들은 `Eager 빈`으로 생성됨
	* 이때 `Lazy 빈`은 다른 빈들보다 먼저 생성되지 않도록, 다른 빈들에게 의존을 당하지 않아야 함
	* `Lazy 빈`이라도 ApplicationContext가 생성 과정에서 이를 무시하고 먼저 생성할 수 있음
	* 따라서, 개발자가 예측하지 못한 결과를 낳을 수 있음
* 이 단계 이후에 빈 객체들이 생성되지만 아직 사용할 수는 없어, 각 빈의 포인터는 BeanFactory를 가리킴

### Setters Called
* 빈 객체들이 인스턴스화된 이후에는 해당 빈이 주입될 setter 메서드들을 호출하는 과정을 거침
* 이때 빈이 주입될 setter 메서드들은 `@Autowired`로 선언되어야 됨
* 빈들을 사용하기 위한 모든 초기화 과정이 완료되지만, 아직까지 빈을 사용할 수는 없음

### Bean Post-Processing (Pre & Post-Init)
* 빈으로 사용될 객체들을 조정할 수 있는 마지막 지점으로, 각 빈들에 대해 추가적인 특성을 추가할 수 있음

### Initializer
* 스프링에서는 다양한 Initializer 메서드들을 제공하며, `@PostConstruct`도 이 중 일부임
* 이 단계에서 모든 종속성들에 대한 주입이 완료되고, 각 빈이 사용될 준비가 완료됨
* 이 단계 이후에 빈들은 모두 인스턴스화 및 초기화가 완료된 상태

### Destruction
* `ApplicationContext`가 종료될 때 수행되는 단계로, 이 과정에서 `@PreDestroy` 메서드가 실행됨
	* 한 번 종료된 `ApplicationContext`는 재사용될 수 없음
	* 프로토타입 빈의 경우에는 컨텍스트가 생성 및 주입 단계만 관여하기 때문에 빈을 제거하지 않음
* `ApplicationContext`는 빈들에 대한 참조를 해제하여 Garbage Collector가 빈을 제거하도록 함