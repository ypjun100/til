# TCP 프로토콜

* TCP/IP 4계층 중에 전송계층에 속하는 프로토콜로, 패킷 사이의 순서를 보장, 에러없이 교환 가능
* 연결지향 프로토콜을 제공하기 위해 가상회선 패킷 교환 방식 사용
* **연결지향 프로토콜**
	* 두 컴퓨터 간의 1:1 연결 상태를 유지하며, 데이터 교환을 위한 전용 데이터 선로를 구축함
	* 이때 만들어진 선로를 Session이라 하며, 데이터의 신뢰도가 중요한 경우에 사용됨
* **가상회선 패킷 교환 방식**
	![](https://woovictory.github.io/img/datagram_packet.png)
	* 연결지향 프로토콜을 지원하기 위한 기능으로, 사전에 전용회선이 있는 것처럼 가상의 연결통로 설정
	* 각 패킷에는 가상회선 식별자가 포함되어 있어 각 패킷은 해당 식별자를 토대로 라우팅이 진행됨
	* 이러한 방식을 통해 데이터의 전송순서를 보장할 수 있음

### TCP 연결 성립 과정
![](https://thebook.io/img/080326/085.jpg)
* TCP는 신뢰성을 확보하기 위해 `3-way handshake`라는 작업을 진행함 
* 이 과정 이후에 실제 데이터 전송을 시작함
* `SYN`은 Synchronization의 약자, `ACK`는 ACKnowledgement의 약자
1. `SYN 단계` : 클라이언트는 클라이언트의 ISN을 담아 SYN 패킷을 서버로 전송함
	* ISN(Initial Sequence Number)은 첫 번째 패킷에 할당된 임의의 시퀀스 번호
2. `SYN + ACK 단계` : 서버가 SYN을 수신하면, 서버의 ISN과 클라이언트 ISN + 1을 승인번호로 전송함
3. `ACK 단계` : 클라이언트는 서버 ISN + 1 값을 승인번호에 담아 서버로 전송함

### TCP 연결 해제 과정
![](https://thebook.io/img/080326/086.jpg)
* TCP가 연결을 해제할 때에는 `4-way handshake` 과정이 발생함
1. 클라이언트가 연결을 종료하기 위해 FIN 패킷을 보낸 뒤, FIN_WAIT_1 상태로 서버의 응답을 기다림
2. 서버는 ACK 패킷 전송 후 CLOSE_WAIT 상태로 대기, 패킷을 받은 클라이언트는 FIN_WAIT_2로 대기
3. CLOSE_WAIT 상태인 서버가 연결을 종료할 준비가 되면 클라이언트에게 FIN 패킷을 전송
4. 패킷을 받은 클라이언트가 TIME_WAIT 상태로 ACK 패킷을 전송하면 서버는 CLOSED 상태가 됨
5. 이후 클라이언트는 일정 시간을 대기한 후에 연결을 최종적으로 종료하게 됨
	* 클라이언트에서 연결 종료를 하기 전 대기를 하는 이유는 패킷 지연을 대비하기 위함
	* 만약 패킷이 연결이 종료된 이후에 도착한다면, 이를 처리하지 못해 데이터 무결성 문제가 발생함