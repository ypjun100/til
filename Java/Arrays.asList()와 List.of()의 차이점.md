# Arrays.asList()와 List.of()의 차이점

|                   | 원소 추가 및 삭제 | set 사용 | 복사 방식 |
| ----------------- | ---------- | ------ | ----- |
| new ArrayList<>() | 가능         | 가능     | 깊은 복사 |
| Arrays.asList()   | 불가능        | 가능     | 얕은 복사 |
| List.of()         | 불가능        | 불가능    | 깊은 복사 |

* ArrayList를 생성하기 위한 방법으로는 `생성자 이용`, `Arrays.asList()`, `List.of()`를 사용할 수 있음
* 생성자를 이용하는 방법과 두 메서드를 이용하는 방법 간에는 차이점이 존재함
* 생성자를 사용한 방법에서는 원소 추가/삭제, 내부 요소를 변경하는 set() 메서드 모두 가능
* 하지만 두 메서드는 기본적으로 원소 추가/삭제가 불가능하며, set() 메서드 사용 가능 여부가 다름
* 또한, 각 방법 별로 복사 방식이 달라 `Arrays.asList()`의 경우 원본 객체의 요소가 변경되면 반환된 객체의 요소도 변경됨

> `Arrays.asList()`와 `List.of()`에서 반환하는 ArrayList는 Arrays 클래스에 정의되어 있는 ArrayList 타입을 반환한다. 따라서, 기존의 ArrayList와는 완전히 다른 클래스이기 때문에 추가 및 변경이 불가능하다.

### 왜 변경이 불가능한 불변 리스트 인가?
```java
Queue<Number> queue = new ArrayDeque<>(List.of(1, 2, 3));
```
* 두 메서드의 반환 타입이 불변 리스트인 이유는 불변 객체만의 이점을 이용해 **다른 컬렉션 자료구조로 변환이 용이하기 때문**
* **불변 객체의 이점**
	* 스레드 안정성 : 동기화가 없이도 여러 스레드에 안전하게 공유하고 액세스할 수 있음
	* 코드 간소화 : 동시성을 위해 설계할 필요가 없으므로 코드가 간소화되고, 버그 가능성이 낮음
	* 향상된 성능 : 항상 동일한 상태를 유지하므로 캐시하고 재사용이 가능함