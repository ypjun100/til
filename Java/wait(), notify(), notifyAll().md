# wait(), notify(), notifyAll()

### 사전 배경
![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/Monitor_%28synchronization%29-Java.png/200px-Monitor_%28synchronization%29-Java.png)

* **락** : 임계 영역의 코드를 실행하기 위한 권한으로, 락을 가진 쓰레드만 임계 영역의 코드를 실행시킬 수 있음
* **모니터** : 다중 쓰레드 환경에서 동시성을 만족하기 위해 락을 포함하고 있는 클래스 혹은 객체를 뜻함
	* **임계 영역에 동시에 액세스 하는 것을 방지하고, 쓰레드가 기다릴 수 있도록 하는 동기화 구성**
	* 모니터 내에는 대기 상태의 쓰레드를 위한 `대기 풀`과 실행 직전의 쓰레드를 위한 `준비 풀`이 존재함
* **Java 내에 존재하는 모든 객체의 인스턴스는 별도의 락을 포함한 모니터를 갖고 있음**

### `wait()`, `notify()`, `notifyAll()`
* 한 쓰레드가 락을 보유한 상태로 무기한 대기하면 다른 쓰레드가 계속 락을 기다릴 수 밖에 없음
	* 따라서, 쓰레드가 더 이상 작업을 진행하지 못하는 경우 락을 다른 쓰레드에게 넘길 수 있어야 함
* 이 작업을 유기적으로 처리하기 위해 `wait()`, `notify()`, `notifyAll()` 메서드를 사용함
* 각 메서드는 Object 클래스에 정의되어 있으며, 임계 영역 안에서만 사용이 가능함

> `wait()`, `notify()`, `notifyAll()` 메서드가 Thread 클래스가 아닌 Object 클래스에 정의되어 있는 이유는, 만약 세 개의 메서드가 Thread 클래스에 정의되어 있는 경우, 특정 쓰레드에서 락을 넘기고자 할 때 어떤 쓰레드가 현재 모니터의 락을 얻고자 대기하고 있는지 확인하기 어렵기 때문이다.

* `wait()`는 작업을 수행하던 쓰레드에서 더 이상 작업을 진행할 수 없어 가지고 있던 락을 반환할 때 호출함
* `notify()`는 락을 가진 쓰레드가 호출하며, 대기 중인 쓰레드 중 하나가 모니터 내의 준비 풀으로 이동됨
	* **실행되는 쓰레드는 대기 풀에서 임의로 결정되며, 순서를 보장하지 않음**
	* 만약 준비 풀로 이동한 쓰레드가 아직 준비 상태가 아닌 경우 다시 준비 풀로 들어감
* `notifyAll()`은 대기 중인 모든 쓰레드를 준비 풀로 이동시켜 모든 쓰레드가 한 번씩 락을 갖도록 함


### `notify()`의 문제점
* `notify()`는 대기 풀에 있던 임의의 쓰레드를 실행시키기 때문에 특정 쓰레드가 대기 풀에 갇힐 수 있음
* 또한, `notify()`가 호출되지 않는다면 대기 상태인 쓰레드는 계속 대기 풀에 잔존하게 됨
* 따라서, **대기 풀의 전체 쓰레드를 준비 큐로 옮겨주는 `notifyAll()`을 사용해야 함**

> 하지만 `notifyAll()`은 아직 준비가 되지 않은 쓰레드도 실행 상태로 바꾸기 때문에 불필요한 작업이 수반된다. 그래서 `notify()`와 `notifyAll()`이 가진 문제를 해결하기 위해 Lock과 Condition을 이용한 동기화 방법이 요구된다.