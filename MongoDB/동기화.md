# 동기화

* 몽고DB는 프라이머리가 수행한 쓰기를 모두 포함하는 로그, oplog를 보관함으로써 복제를 수행하게 됨
* oplog는 프라이머리에 있는 제한 컬렉션이며, 세컨더리는 이 컬렉션에 복제를 위한 연산을 쿼리하게 됨
* 각 세컨더리는 프라이머리로부터 복제한 작업을 기록하여 다른 멤버를 위한 동기화 소스로 사용되도록 함
	* 세컨더리는 동기화하는 멤버로부터 연산을 가져와 데이터셋에 적용한 뒤, 자신의 oplog에 씀
* 세컨더리가 어떤 이유로든 다운되면, 재시작할 때 oplog에 있는 마지막 연산과 동기화하게 됨
* oplog의 각 작업은 멱등으로, 대상 데이터셋에 한 번 적용되든 여러 번 적용되든 동일한 결과를 생성함

> 사용자의 쿼리가 oplog에 저장될 때에는 그대로 저장되는 게 아닌, 몽고DB 내에서 한번 원자 단위로 변환이 된 이후에 저장된다. 그 예시로, `$inc`를 사용하는 업데이트 쿼리는, 보기에는 oplog 내에서 멱등성을 보장하지 않을 것 같으나 실제로는 몽고DB에 의해 변환되어 `$set`으로 변환된다. 따라서, oplog 내에서는 `$inc`도 멱등성을 보장하게 된다.

### oplog 용량을 늘려야 하는 경우

* oplog는 크기가 고정되어 있기에 담을 수 있는 연산의 수가 정해져 있으며, 일반적으로 기본 크기면 충분함
* 하지만 복제 셋 워크로드가 다음 패턴 중 하나와 같다고 예상한다면, 기본값보다 큰 oplog를 생성할 수 있음
<br>
* **한번에 여러 도큐먼트 갱신**
	* oplog는 멱등성을 유지하기 위해 다중갱신을 개별 작업으로 변환하는데, 이때 공간을 많이 차지함
* **삽입한 데이터와 동일한 양의 데이터 삭제**
	* 삽입한 데이터와 같은 양의 데이터를 삭제하면, 디스크 사용량은 증가하지 않지만, oplog는 증가함
* **상당한 수의 내부 갱신**
	* 도큐먼트 내부 필드의 많은 갱신이 이뤄지면, 디스크 사용량은 증가하지 않지만 oplog는 클 수 있음

> mongod가 oplog를 만들기 전에 `oplogSizeMB` 옵션을 사용해 oplog의 크기를 지정할 수 있다.