# 복합 인덱스

```shell
> db.users.find().sort({ "age": 1, "username": 1 })
```

* 인덱스는 모든 값을 정렬된 순서로 보관하므로 인덱스 키로 도큐먼트를 정렬하는 작업이 훨씬 빨라질 수 있음
* 하지만, 인덱스가 다른 필드보다 앞에 있는 경우에만 해당하며, 위 쿼리에서는 정렬에 큰 도움이 되지 않음
	* 쿼리는 먼저 `age`로 정렬한 후에 `username`으로 정렬하기에 **정렬을 위해서 복합 인덱스가 필요함
* 위 쿼리를 최적화하기 위해서는 `age`와 `username`에 해당하는 복합 인덱스를 새로 생성해야 함

```shell
> db.users.createIndex({ "age": 1, "username": 1 })
```

* 복합 인덱스는 2개 이상의 필드로 구성된 인덱스로, 쿼리의 검색 조건에 여러 개의 키가 존재할 때 유용함
* 아래는 `age`와 `username`에 복합 인덱스가 적용된 상태에서 각 쿼리마다 몽고DB의 인덱스 이용 방법임
* 위 `createIndex`를 통해서 아래와 같이 나이, 사용자명을 포함한 필드와 레코드 식별자가 생성됨

```plain
[0, "user10020"] -> 8623513776
[0, "user1002"] -> 8599246768
...
[1, "user100113"] -> 8623525680
[1, "user100280"] -> 8623547056
```

* 레코드 식별자는 몽고DB 내부에서 스토리지 엔진에 의해 사용되며, 도큐먼트 데이터를 찾는 데 사용됨

### db.users.find({"age":21}).sort({"username":-1})

* 해당 쿼리는 단일 값을 찾는 동등 쿼리로, 생성한 인덱스의 두 번째 필드로 인해 결과는 이미 정렬된 상태임
* 따라서, 몽고DB는 `{"age": 21}`과 일치하는 마지막 항목부터 순서대로 인덱스를 탐색하기 시작함
* 몽고DB는 정확한 나이로 건너뛸 수 있으며, 데이터를 올바른 순서로 반환하기에 결과를 정렬할 필요가 없음
	* 몽고DB는 인덱스를 어느 방향으로도 쉽게 탐색하므로 정렬 방향에는 문제가 되지 않음

### db.users.find({"age": {"\$gte": 21, "\$lte": 30}})

* 몽고DB는 쿼리에 포함된 `age`를 인덱스의 첫 번째 필드인 `age`를 사용하여 일치하는 도큐먼트를 반환함

### db.users.find({"age": {"\$gte": 21, "\$lte": 30}}).sort({"username": 1})

* 몽고DB는 21~30세에 맞는 도큐먼트를 찾기 위해 인덱스를 이용하지만, 정렬할 때에는 사용하지 않음
	* \[나이, 이름\]으로 인덱스가 생성되었기에 조건 검색 결과에서 정렬을 위해 인덱스를 사용할 수 없음
* 정렬은 메모리 내에서 진행하며, 만약 결과가 32메가바이트 이상인 경우, 데이터가 많아 정렬을 거부함
	* 정렬 거부를 피하기 위해서 인덱스를 생성한 다음 `sort`와 `limit`을 함께 사용할 수 있음

### 복합 인덱스를 이용한 정렬 최적화

* 데이터를 정렬할 때 인덱스가 없는 경우 몽고DB는 데이터를 검색한 후에 메모리에서 정렬을 수행해야 함
	* 데이터가 많을수록 메모리 사용량이 증가하며, 메모리를 초과하는 결과는 쿼리가 실패할 수 있음
	* **이때, 인덱스를 이용한다면, 거대한 인메모리 정렬이 필요하지 않다는 장점이 존재함**

```shell
> db.users.createIndex({ "age": 1, "username": 1 })
```

* 복합 인덱스는 오른쪽 방향으로 탐색되기에 인덱스의 첫 필드가 가장 먼저 필터링되거나 정렬에 활용됨
* 위의 인덱스에서 `age`로 정렬할 때는 효율적이지만, `username`으로 정렬하면 전체 인덱스를 훑어야 함
* **따라서, 특정 정렬 기준이 자주 사용된다면 그 필드를 첫 번째 인덱스 키로 설정하는 것이 최적화의 핵심임