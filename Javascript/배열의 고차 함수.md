# 배열의 고차 함수

* 고차 함수(HOF)는 함수를 인수로 전달받거나 함수를 반환하는 함수이며, 함수형 프로그래밍에 기반함
* 자바스크립트의 함수는 일급 객체이므로 함수를 값처럼 인수로 전달하거나 반환할 수도 있음
* 자바스크립트는 객체나 배열과 같은 요소들에 대해 다양한 고차 함수를 지원함

> 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거(가독성을 해치기 때문)하여 복잡성을 해결하고 변수의 사용을 억제(누군가에 의해 언제든지 변경할 수 있기 때문)하여 상태 변경을 피하려는 프로그래밍 패러다임이다.

### Array.prototype.sort

```js
const fruits = ['Banana', 'Orange', 'Apple'];

// 오름차순(ascending) 정렬
fruits.sort();

// sort 메서드는 원본 배열을 직접 변경함
console.log(fruits); // ['Apple', 'Banana', 'Orange']
```

* 원본 배열을 직접 변경한 뒤 정렬된 배열또한 반환하며, 기본적으로 오름차순으로 요소를 정렬함
* 만약 내림차순으로 정렬하기 위해서는 `sort`로 정렬한 뒤에 `reverse` 메서드를 사용해야 함

```js
[2, 10].sort(); // -> [10, 2]

[2, 10].sort((a, b) => a - b); // -> [2, 10]
```

* `sort()`의 정렬 순서는 유니코드 코드의 순서를 따라 배열 요소가 숫자이더라도 문자열로 변경하여 정렬함
* 위와 같이 정렬 방법을 지정하지 않으면, 우리가 기대한 바와 다르게 정렬을 수행하게 됨
* 따라서, **숫자 요소를 정렬할 때는 메서드에 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 함**
	* 비교 함수의 반환값이 음수면 첫 번째 인수를 우선, 0이면 정렬하지 않고, 양수면 두 번째 인수를 우선

### Array.prototype.forEach

```js
[1, 2, 3].forEach((item, index, arr) => {
	console.log(item, index, arr);
});

// -> 1, 0, [1, 2, 3]
// -> 2, 1, [1, 2, 3]
// -> 3, 2, [1, 2, 3]
```

* `for`문을 대체하는 함수형 프로그래밍을 위한 고차 함수로, 콜백 함수 내에서 3개의 인자를 받을 수 있음
	* 배열의 각 요소값과 인덱스, `forEach` 메서드를 호출한 배열 자체(`this`)
	* 콜백 함수 내에서 `this`를 사용하게 된다면, 해당 콜백 함수가 정의된 상위 스코프의 `this`를 참조함

```js
const numbers = [1, 2, 3];

// arr은 현재 배열인 this와 같으므로, 이를 통해 현재 배열을 수정할 수 있음
numbers.forEach((item, index, arr) => { arr[index] = item ** 2; });
```

### Array.prototype.map

```js
[1, 2, 3].map((item, index, arr) => {
	console.log(item, index, arr);
	return item;
});

// -> 1, 0, [1, 2, 3]
// -> 2, 1, [1, 2, 3]
// -> 3, 2, [1, 2, 3]
// 반환값: [1, 2, 3]
```

* 자신을 호출한 배열의 각 요소를 순회하면서 콜백 함수를 반복 호출한 뒤 새로운 배열을 만들어 반환함
* `forEach`와 마찬가지로 배열의 각 요소값과 인덱스, `map`을 호출한 배열(`this`)을 콜백 함수에서 받음

### Array.prototype.filter

```js
const numbers = [1, 2, 3, 4, 5];

// 배열 내에서 홀수인 요소들만 추출함
console.log(numbers.filter(item => item % 2)); // -> [1, 3, 5]
```

* 배열의 요소를 순회하면서 콜백 함수를 실행시켜 함수의 반환값이 참인 요소로 구성된 새로운 배열을 반환함
* `forEach`와 마찬가지로 배열의 각 요소값과 인덱스, 메서드를 호출한 배열(`this`)을 콜백 함수에서 받음

### Array.prototype.reduce

```js
// 배열 원소의 합을 구함
console.log([1, 2, 3, 4].reduce((accumulator, currentValue, index, array) => {
	return accumulator + currentValue;
}, 0)); // 0은 초기값
// -> 10
```

* 배열의 요소를 순회하며 콜백 함수를 호출하는데, 함수의 반환값을 다음 순회 시의 첫 번째 인수로 전달함
* 위 과정을 반복하여 최종적으로는 하나의 결과값을 만들어 반환하며, 원본 배열은 변경되지 않음
* 인수로는 초기값 또는 콜백 함수의 이전 반환값, 각 배열의 요소값과 인덱스, 배열 자체(`this`)를 받음

### Array.prototype.some

```js
// 배열의 요소 중 10보다 큰 요소가 1개 이상 존재하는지 확인
[5, 10, 15].some(item => item > 10); // -> true

// 빈 배열은 언제나 false를 반환함
[].some(item => item > 3); // -> false
```

* 배열의 요소를 순회하며 콜백 함수를 호출하며, 함수의 반환값이 하나라도 참이면 참, 아니면 거짓을 반환함
* 즉, 배열의 요소 중에 콜백 함수의 조건을 만족하는 요소가 1개 이상 존재하는지 확인한 뒤 논리값을 반환함
	* 각 요소에 대해 조건을 확인하여 이 조건의 결과에 OR 연산을 진행한 것과 같은 결과를 냄
* 다른 메서드와 마찬가지로 콜백 함수는 각 요소값과 인덱스, 배열 자체(`this`)를 순차적으로 전달받음

### Array.prototype.every

```js
// 배열의 모든 요소가 3보다 큰지 확인
[5, 10, 15].every(item => item > 3); // -> true

// 빈 배열은 언제나 true를 반환함
[].every(item => item > 3); // -> true
```

* 배열의 요소를 순회하며 콜백 함수를 호출하며, 함수의 반환값이 모두 참이면 참, 아니면 거짓을 반환함
* 즉, 배열의 모든 요소가 콜백 함수의 조건을 모두 만족하는지 확인하여, 그 결과를 논리값으로 반환함
	* `some()` 메서드가 조건의 결과에 OR 연산을 진행했다면, `every()` 메서드는 AND 연산과 같음
* 단, 만약 배열이 빈 배열인 경우 언제가 `true`를 반환하므로 주의해야 함
* 다른 메서드와 마찬가지로 콜백 함수는 각 요소값과 인덱스, 배열 자체(`this`)를 순차적으로 전달받음

### Array.prototype.find

```js
const users = [
	{ id: 1, name: 'Lee' },
	{ id: 2, name: 'Kim' },
	{ id: 2, name: 'Choi' },
	{ id: 3, name: 'Park' },
];

// id가 2인 첫 번째 요소를 반환함
users.find(user => user.id === 2); // -> { id: 2, name: 'Kim' }
```

* 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 반환값이 참인 첫 번째 요소를 반환함
* 콜백 함수의 반환값이 참인 요소가 존재하지 않는다면 `undefined`를 반환함
* 다른 메서드와 마찬가지로 콜백 함수는 각 요소값과 인덱스, 배열 자체(`this`)를 순차적으로 전달받음
* 만약 콜백 함수의 조건을 만족하는 첫 번째 요소의 값이 아닌 인덱스를 반환하려면 `findIndex`를 사용함