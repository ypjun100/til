# 함수 선언문의 중의적 표현

### 함수 선언문

```js
// 함수 선언문
function add(x, y) {
	return x + y;
}
// -> undefined
 
// 함수 리터럴
function(x, y) {
	return x + y;
}

// 함수 리터럴을 이용한 함수 표현식
var add = function(x, y) {
	return x + y;
}
```

* 함수 선언문은 함수를 생성하기 위한 방법 중 하나로, 함수 리터럴과 비슷한 형식이지만 함수 이름을 가짐
* 또한, 함수 선언문은 표현식이 아닌 문으로, 함수 선언문을 실행하면 완료 값인 `undefined`가 출력됨
* 하지만, 함수 표현식에서는 함수 리터럴의 완료 값을 받은 후, 이를 변수에 저장하는 형식을 취하고 있음
	* 자바스크립트에서 코드의 문맥에 따라 코드를 다르게 해석하는 중의적 표현이 가능하기 때문임

### 자바스크립트의 중의적 표현

```js
// 중괄호가 블록으로 사용되는 경우
if(condition) { ... }

// 중괄호가 객체 리터럴로 사용되는 경우
var something = { ... };
```

* 중의적 표현이란 자바스크립트 엔진이 코드의 문맥에 따라 코드를 다르게 해석할 수 있는 코드를 뜻함
* 그 예시로, 위 코드에서 `{}`은 엔진의 해석에 따라 블록문이 될 수도 있고, 객체 리터럴이 될 수도 있음
	* `{}`이 단독으로 사용되면 블록문으로 해석하고, `{}`이 피연산자로 사용되면 객체 리터럴로 해석함
* 함수 리터럴도 단독으로 사용하면 함수 선언문으로, 피연산자로 사용하면 함수 리터럴 표현식으로 해석됨
	* 이때 두 방식 모두 함수가 생성되는 것을 동일하지만, 내부 동작에 차이가 있음

```js
// 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석됨
// 함수 선언문에서는 함수 이름을 생략할 수 없음
function foo() { console.log('foo'); }
foo(); // -> foo

// 함수 리터럴을 피연산자로 사용하면 함수 리터럴 표현식으로 해석됨
// 함수 리터럴에서는 함수 이름을 생략할 수 있음
(function bar() { console.log('bar'); }); // -> ƒ bar() { console.log('bar'); }
bar(); // ReferenceError: bar is not defined
```

* 기본적으로 함수 리터럴에서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자임
	* 따라서, 코드에서 명시한 함수 이름은 함수가 존재하는 메모리 셀 내에서만 접근이 가능함
	* **함수 선언문에서 함수 이름으로 함수를 참조할 수 있는 이유는 암묵적으로 식별자를 생성하기 때문임**
	* 함수를 호출할 때 함수 이름으로 호출가능한 것은 사실 암묵적으로 생성된 식별자로 호출하는 것임
* 위 코드의 `bar()` 함수는 메모리 상에 저장되었지만, 이에 대한 식별자가 없어서 참조할 수 없는 경우임

![](https://velog.velcdn.com/images/kozel/post/3b48511a-ac0e-441e-a2a9-f31ba2325374/image.jpeg)